<!DOCTYPE html><html><head><title>vc | Rendering</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="robots" content="index,follow"><meta name="theme-color" content="#212121"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://fonts.googleapis.com/css?family=Hind:400,700&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:300,400&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons%7CMaterial+Icons+Outlined&amp;display=swap" rel="stylesheet"><style>
      body, input, button {
        font-family: 'Hind', sans-serif;
      }

      code, .hljs {
        font-family: 'Source Code Pro', 'Courier New', Courier, monospace;
      }

      .icon-font {
        font-family: 'Material Icons';
        font-weight: normal;
        font-style: normal;
        font-size: 24px;  /* Preferred icon size */
        display: inline-block;
        line-height: 1;
        text-transform: none;
        letter-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        direction: ltr;
      
        /* Support for all WebKit browsers. */
        -webkit-font-smoothing: antialiased;
        /* Support for Safari and Chrome. */
        text-rendering: optimizeLegibility;
      
        /* Support for Firefox. */
        -moz-osx-font-smoothing: grayscale;
      
        /* Support for IE. */
        font-feature-settings: 'liga';
      }

      .icon-font.outline {
        font-family: 'Material Icons Outlined';
      }
    </style><link href="/vc/docs/assets/codedoc-styles.css" rel="stylesheet"><script async="" defer="" src="/vc/docs/assets/codedoc-bundle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"></head><body><div class="header-0-0-11"><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><a class="github-button" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-show-count="false" data-size="large" href="https://github.com/alex22barreto/vc/">Star</a><br><br><a class="watermark-0-0-10" href="https://github.com/CONNECT-platform/codedoc" target="_blank">Created With<svg viewBox="0 0 536 296" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="codedoc" transform="translate(-244.000000, -364.000000)" fill-rule="nonzero"><path d="M580,532 C615.346224,532 644,560.653776 644,596 C644,631.346224 615.346224,660 580,660 C544.653776,660 516,631.346224 516,596 C516,560.653776 544.653776,532 580,532 Z M716,532 C751.346224,532 780,560.653776 780,596 C780,631.346224 751.346224,660 716,660 L692,660 C687.581722,660 684,656.418278 684,652 C684,647.581722 687.581722,644 692,644 L716,644 C742.509668,644 764,622.509668 764,596 C764,569.490332 742.509668,548 716,548 L692,548 C687.581722,548 684,544.418278 684,540 C684,535.581722 687.581722,532 692,532 L716,532 Z M468,532 C472.418278,532 476,535.581722 476,540 L476,652 C476,656.418278 472.418278,660 468,660 L444,660 C408.653776,660 380,631.346224 380,596 C380,560.653776 408.653776,532 444,532 L468,532 Z M332,532 C336.418278,532 340,535.581722 340,540 L340,652 C340,656.418278 336.418278,660 332,660 L252,660 C247.581722,660 244,656.418278 244,652 L244,540 C244,535.581722 247.581722,532 252,532 L332,532 Z M580,548 C553.490332,548 532,569.490332 532,596 C532,622.509668 553.490332,644 580,644 C606.509668,644 628,622.509668 628,596 C628,569.490332 606.509668,548 580,548 Z M461,548 L444,548 C417.490332,548 396,569.490332 396,596 C396,622.509668 417.490332,644 444,644 L461,644 L461,548 Z M444,364 C479.346224,364 508,392.653776 508,428 C508,463.346224 479.346224,492 444,492 C408.653776,492 380,463.346224 380,428 C380,392.653776 408.653776,364 444,364 Z M332,364 C336.418278,364 340,367.581722 340,372 C340,376.418278 336.418278,380 332,380 L308,380 C281.490332,380 260,401.490332 260,428 C260,454.509668 281.490332,476 308,476 L332,476 C336.418278,476 340,479.581722 340,484 C340,488.418278 336.418278,492 332,492 L308,492 C272.653776,492 244,463.346224 244,428 C244,392.653776 272.653776,364 308,364 L332,364 Z M580,364 C615.346224,364 644,392.653776 644,428 C644,463.346224 615.346224,492 580,492 L556,492 C551.581722,492 548,488.418278 548,484 L548,372 C548,367.581722 551.581722,364 556,364 L580,364 Z M772,364 C776.418278,364 780,367.581722 780,372 C780,376.418278 776.418278,380 772,380 L700,380 L700,420 L772,420 C776.418278,420 780,423.581722 780,428 C780,432.418278 776.418278,436 772,436 L700,436 L700,476 L772,476 C776.418278,476 780,479.581722 780,484 C780,488.418278 776.418278,492 772,492 L692,492 C687.581722,492 684,488.418278 684,484 L684,372 C684,367.581722 687.581722,364 692,364 L772,364 Z M444,380 C417.490332,380 396,401.490332 396,428 C396,454.509668 417.490332,476 444,476 C470.509668,476 492,454.509668 492,428 C492,401.490332 470.509668,380 444,380 Z M580,380 L563,380 L563,476 L580,476 C606.509668,476 628,454.509668 628,428 C628,401.490332 606.509668,380 580,380 Z"></path></g></svg></a></div><div id="-codedoc-container" class="container"><h1 id="rendering" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Rendering</h1><h2 id="problem-statement" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Problem statement</h2><p>Realizar una indagación teórica de algún algoritmo de visibilidad o algún método de iluminación global.</p><h2 id="background" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Background</h2><h3 id="path-tracing" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Path tracing</h3><p>Path tracing o trazado de caminos, es un método de renderizado de imágenes, similar al método ray tracing, que utiliza muestras aleatorias para calcular gradualmente una imagen final con el fin de que la iluminación global sea fiel a la realidad.</p><p>La iluminación global hace referencia al conjunto de algoritmos usados en gráficos que buscan añadir realismo a la modelación de la luz en escenas 3D. Estos algoritmos tienen en cuenta la luz directa de una fuente de luz y los rayos de luz provenientes de las reflexiones de luz sobre las superficies de la escena.</p><p>El trazado de ruta es un algoritmo que envía rayos desde la cámara y, cuando un rayo golpea una superficie reflectante o refractiva, repite el proceso hasta que alcanza una fuente de luz. La serie de rayos de la cámara a la luz forma un "camino".</p><h3 id="historia" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Historia</h3><p>El trazado de caminos fue el primer algoritmo de renderizado utilizado en gráficos. Fue presentado por James Kajiya en 1986, quien lo introdujo en el mismo artículo que describió por primera vez la ecuación de renderizado. 
Este método se introdujo como un algoritmo para encontrar una solución numérica de la integral de la ecuación de renderizado y genera de manera incremental, caminos de eventos de dispersión que comienzan en la cámara y terminan en las fuentes de luz de la escena. Una década más tarde, Lafortune sugirió muchos refinamientos, incluyendo el trazado de caminos bidireccional.</p><p>En 1977, se introdujo el método de transporte de luz de metrópolis, por Eric Veach y Leonidas J. Guibas, el cual pertuba los caminos encontrados con el fin de aumentar el rendimiento de escenas difíciles.</p><p>El interés hacia el algoritmo de trazado de caminos se ha incrementado gracias la potencia de las CPUs y GPUs para renderizar imágenes mucho más rápido. Así, en 2002 Tim Purcell presentó por primera vez un algoritmo de iluminación global que se ejecuta en una GPU. En febrero de 2009, Austin Robison de Nvidia mostró la primera aplicación comercial de trazado de caminos que se ejecuta en una GPU, y otras implementaciones han seguido, como la de Vladimir Koylazov en agosto de 2009. </p><p>En la industria del cine, Blue Sky Studios, Sony Pictures Imageworks, Walt Disney Animation Studios, Pixar Animation Studios, han utilizado el trazado de caminos para alguno de sus proyectos. </p><h3 id="descripción" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Descripción</h3><p>Debido a que el método de trazado de caminos es una solución a la ecuación de renderizado, debe cumplir los siguientes tres principios:</p><ul><li><p><code>Principio de iluminación global:</code> para una escena interior determinada, todos los objetos de la habitación deben aportar iluminación a todos los demás objetos.</p></li><li><p><code>Principio de equivalencia:</code> no hay distinción entre la iluminación emitida por una fuente de luz y la iluminación reflejada por una superficie, es decir que la luz reflejada es equivalente a la luz emitida.</p></li><li><p><code>Principio de dirección:</code> La iluminación que proviene de las superficies debe dispersarse en una dirección particular que es alguna función de la dirección de entrada de la iluminación de llegada y la dirección de salida que se muestrea, por lo cual la luz reflejada y luz dispersada tienen una dirección.</p></li></ul><h3 id="algoritmo-en-pseudocódigo" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Algoritmo en Pseudocódigo</h3><pre class="with-bar"><code class="shell -codedoc-code-snippet code-0-0-3" tabindex="0"><span class="wmbar-0-0-8"><span></span><span></span><span></span><span></span></span><div class="line-0-0-7  -codedoc-code-line" data-content="Color TracePath(Ray ray, count depth) {" id="code1-l1"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">1<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>Color TracePath<span class="token punctuation">(</span>Ray ray, count depth<span class="token punctuation">)</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    if (depth >= MaxDepth) {" id="code1-l2"><span class="lineCounter-0-0-4 -codedoc-line-counter">2<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span><span class="token operator">=</span> MaxDepth<span class="token punctuation">)</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="      return Black;  // Rebotes suficientes." id="code1-l3"><span class="lineCounter-0-0-4 -codedoc-line-counter">3<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>      <span class="token builtin class-name">return</span> Black<span class="token punctuation">;</span>  // Rebotes suficientes.</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    }" id="code1-l4"><span class="lineCounter-0-0-4 -codedoc-line-counter">4<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l5"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">5<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    ray.FindNearestObject();" id="code1-l6"><span class="lineCounter-0-0-4 -codedoc-line-counter">6<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    ray.FindNearestObject<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    if (ray.hitSomething == false) {" id="code1-l7"><span class="lineCounter-0-0-4 -codedoc-line-counter">7<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ray.hitSomething <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="      return Black;  // No hubo intersección." id="code1-l8"><span class="lineCounter-0-0-4 -codedoc-line-counter">8<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>      <span class="token builtin class-name">return</span> Black<span class="token punctuation">;</span>  // No hubo intersección.</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    }" id="code1-l9"><span class="lineCounter-0-0-4 -codedoc-line-counter">9<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l10"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">10<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    Material material = ray.thingHit->material;" id="code1-l11"><span class="lineCounter-0-0-4 -codedoc-line-counter">11<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    Material material <span class="token operator">=</span> ray.thingHit-<span class="token operator">&gt;</span>material<span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    Color emittance = material.emittance;" id="code1-l12"><span class="lineCounter-0-0-4 -codedoc-line-counter">12<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    Color emittance <span class="token operator">=</span> material.emittance<span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l13"><span class="lineCounter-0-0-4 -codedoc-line-counter">13<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    // Escoger una dirección aleatoria y continuar." id="code1-l14"><span class="lineCounter-0-0-4 -codedoc-line-counter">14<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    // Escoger una dirección aleatoria y continuar.</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    Ray newRay;" id="code1-l15"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">15<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    Ray newRay<span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    newRay.origin = ray.pointWhereObjWasHit;" id="code1-l16"><span class="lineCounter-0-0-4 -codedoc-line-counter">16<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    newRay.origin <span class="token operator">=</span> ray.pointWhereObjWasHit<span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    newRay.direction = RandomUnitVectorInHemisphereOf(ray.normalWhereObjWasHit);" id="code1-l17"><span class="lineCounter-0-0-4 -codedoc-line-counter">17<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    newRay.direction <span class="token operator">=</span> RandomUnitVectorInHemisphereOf<span class="token punctuation">(</span>ray.normalWhereObjWasHit<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l18"><span class="lineCounter-0-0-4 -codedoc-line-counter">18<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    // PProbabilidad de newRay" id="code1-l19"><span class="lineCounter-0-0-4 -codedoc-line-counter">19<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    // PProbabilidad de newRay</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    const float p = 1 / (2 * PI);" id="code1-l20"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">20<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    const float p <span class="token operator">=</span> <span class="token number">1</span> / <span class="token punctuation">(</span><span class="token number">2</span> * PI<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l21"><span class="lineCounter-0-0-4 -codedoc-line-counter">21<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    // Calcular el BRDF para el rayo" id="code1-l22"><span class="lineCounter-0-0-4 -codedoc-line-counter">22<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    // Calcular el BRDF para el rayo</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    float cos_theta = DotProduct(newRay.direction, ray.normalWhereObjWasHit);" id="code1-l23"><span class="lineCounter-0-0-4 -codedoc-line-counter">23<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    float cos_theta <span class="token operator">=</span> DotProduct<span class="token punctuation">(</span>newRay.direction, ray.normalWhereObjWasHit<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    Color BRDF = material.reflectance / PI;" id="code1-l24"><span class="lineCounter-0-0-4 -codedoc-line-counter">24<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    Color BRDF <span class="token operator">=</span> material.reflectance / PI<span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l25"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">25<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    // Trazar recursivamente las fuentes de luz reflejadas." id="code1-l26"><span class="lineCounter-0-0-4 -codedoc-line-counter">26<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    // Trazar recursivamente las fuentes de luz reflejadas.</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    Color incoming = TracePath(newRay, depth + 1);" id="code1-l27"><span class="lineCounter-0-0-4 -codedoc-line-counter">27<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    Color incoming <span class="token operator">=</span> TracePath<span class="token punctuation">(</span>newRay, depth + <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l28"><span class="lineCounter-0-0-4 -codedoc-line-counter">28<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    // Aplicar la ecuación de renderizado. " id="code1-l29"><span class="lineCounter-0-0-4 -codedoc-line-counter">29<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    // Aplicar la ecuación de renderizado. </div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    return emittance + (BRDF * incoming * cos_theta / p);" id="code1-l30"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">30<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token builtin class-name">return</span> emittance + <span class="token punctuation">(</span>BRDF * incoming * cos_theta / p<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="  }" id="code1-l31"><span class="lineCounter-0-0-4 -codedoc-line-counter">31<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>  <span class="token punctuation">}</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="" id="code1-l32"><span class="lineCounter-0-0-4 -codedoc-line-counter">32<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="  void Render(Image finalImage, count numSamples) {" id="code1-l33"><span class="lineCounter-0-0-4 -codedoc-line-counter">33<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>  void Render<span class="token punctuation">(</span>Image finalImage, count numSamples<span class="token punctuation">)</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    foreach (pixel in finalImage) {" id="code1-l34"><span class="lineCounter-0-0-4 -codedoc-line-counter">34<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    foreach <span class="token punctuation">(</span>pixel <span class="token keyword">in</span> finalImage<span class="token punctuation">)</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="      foreach (i in numSamples) {" id="code1-l35"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">35<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>      foreach <span class="token punctuation">(</span>i <span class="token keyword">in</span> numSamples<span class="token punctuation">)</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="        Ray r = camera.generateRay(pixel);" id="code1-l36"><span class="lineCounter-0-0-4 -codedoc-line-counter">36<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>        Ray r <span class="token operator">=</span> camera.generateRay<span class="token punctuation">(</span>pixel<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="        pixel.color += TracePath(r, 0);" id="code1-l37"><span class="lineCounter-0-0-4 -codedoc-line-counter">37<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>        pixel.color <span class="token operator">+=</span> TracePath<span class="token punctuation">(</span>r, <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="      }" id="code1-l38"><span class="lineCounter-0-0-4 -codedoc-line-counter">38<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>      <span class="token punctuation">}</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="      pixel.color /= numSamples;  // Promedio de muestras." id="code1-l39"><span class="lineCounter-0-0-4 -codedoc-line-counter">39<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>      pixel.color /<span class="token operator">=</span> numSamples<span class="token punctuation">;</span>  // Promedio de muestras.</div><br><div class="line-0-0-7  -codedoc-code-line" data-content="    }" id="code1-l40"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">40<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span></div><br><div class="line-0-0-7  -codedoc-code-line" data-content="  }" id="code1-l41"><span class="lineCounter-0-0-4 prim -codedoc-line-counter">41<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>  <span class="token punctuation">}</span></div><br></code></pre><p>Este es el procedimiento para realizar un trazado de camino sencillo. La función TracePath calcula una sola muestra de un píxel, donde solo se considera recorrido de recopilación. Luego, todas las muestras se promedian para obtener el color de salida.   </p><h3 id="muestreo-aleatorio" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Muestreo aleatorio</h3><p>En Path Tracing, los rayos se distribuyen aleatoriamente dentro de cada píxel en la sala de la cámara y en cada intersección con un objeto en la escena, se genera un nuevo rayo de reflexión apuntando en una dirección aleatoria. Después de un cierto número de rebotes, cada rayo finalmente abandona la escena o es absorbido. Cuando un rayo termina de indagar en la escena, se calcula un valor de muestra en función de los objetos contra los que rebotó. El valor de la muestra se suma al promedio del píxel de origen.</p><p>Las muestras en una imagen con trazado de caminos se distribuyen uniformemente en todos los píxeles. El color de cada píxel es el promedio de todas las muestras calculadas para ese píxel.
Los componentes aleatorios en trazado de caminos, hacen que la imagen renderizada parezca ruidosa pero el ruido disminuye con el tiempo a medida que se calculan más y más muestras.</p><p>El factor decisivo para la calidad del renderizado es el número de muestras por píxel (SPP). Cuanto mayor sea el SPP que tenga en una imagen renderizada, menos ruido se notará. 
Las tomas en exteriores se pueden reproducir con SPP relativamente bajos cuando se tiene la luz solar. Pero en tomas en interiores y escenas similares en entornos con poca luz, se requieren un número de SPP mucho más alto para verse bien. </p><h3 id="trazado-de-caminos-bidireccional" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Trazado de caminos bidireccional</h3><p>El muestreo de un punto se puede realizar mediante cualquiera de los dos siguientes enfoques:</p><ul><li><p>Trazado de camino hacia atrás: donde los caminos se generan empezando desde la cámara y rebotando alrededor de la escena hasta que encuentre una fuente de luz.</p></li><li><p>Trazado de luz: donde el camino se genera desde las fuentes de luz y rebotan alrededor de la escena hasta que encuentran la cámara.</p></li></ul><p>El trazado de caminos bidireccional proporciona un algoritmo que combina los dos enfoques y puede producir una varianza más baja que cualquiera de los métodos por separado. Para cada muestra, se trazan dos caminos de forma independiente: uno utilizando la fuente de luz y otro desde la cámara. Esto produce un conjunto de posibles estrategias de muestreo, donde cada vértice de un camino se puede conectar directamente a cada vértice del otro. Esto funciona particularmente bien para escenas que se iluminan principalmente mediante iluminación indirecta. </p><h3 id="metropolis-light-transport" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Metropolis light transport</h3><p>Este algoritmo fue propuesto en 1997 por Veach y Guibas y creado para lograr una convergencia más rápida en escenas en las que la luz debe atravesar pasillos extraños o pequeños agujeros para llegar a la parte de la escena que está viendo la cámara. </p><p>El algoritmo consta de dos fases, en la primera se utiliza un trazado de rayos bidireccional para generar un conjunto de caminos iniciales de la luz y en la segunda fase, cada uno de estos caminos sufrirá una mutación que será aceptada o rechazada según una probabilidad. En este sentido, el algoritmo "recuerda" las trayectorias exitosas desde las fuentes de luz hasta la cámara. </p><h2 id="conclusions--future-work" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Conclusions &amp;&amp; future work</h2><p>Path tracing es un algoritmo que se basa en lanzar rayos desde la cámara a la escena y que cuando uno de estos se encuentra con un objeto, se lanza un nuevo rayo en una dirección aleatoria, formando así un camino de rayos. Este proceso puede llegar a ser impreciso y por eso es necesario repetir el proceso la mayor cantidad de veces para poder obtener un resultado satisfactorio.</p><p>Para un trabajo futuro se espera realizar la implementación del algoritmo y profundizar más en las aplicaciones.</p><script id="anYalWHvLu">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("anYalWHvLu", "7H5M9Vp+I8cVV99ELLvnzg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="contentnav-0-0-16" data-no-search=""><a href="#rendering" class="h1" data-content-highlight="rendering">Rendering</a><a href="#problem-statement" class="h2" data-content-highlight="problem-statement">Problem statement</a><a href="#background" class="h2" data-content-highlight="background">Background</a><a href="#path-tracing" class="h3" data-content-highlight="path-tracing">Path tracing</a><a href="#historia" class="h3" data-content-highlight="historia">Historia</a><a href="#descripción" class="h3" data-content-highlight="descripción">Descripción</a><a href="#algoritmo-en-pseudocódigo" class="h3" data-content-highlight="algoritmo-en-pseudocódigo">Algoritmo en Pseudocódigo</a><a href="#muestreo-aleatorio" class="h3" data-content-highlight="muestreo-aleatorio">Muestreo aleatorio</a><a href="#trazado-de-caminos-bidireccional" class="h3" data-content-highlight="trazado-de-caminos-bidireccional">Trazado de caminos bidireccional</a><a href="#metropolis-light-transport" class="h3" data-content-highlight="metropolis-light-transport">Metropolis light transport</a><a href="#conclusions--future-work" class="h2" data-content-highlight="conclusions--future-work">Conclusions &amp;&amp; future work</a></div></div><div id="-codedoc-toc" class="toc-0-0-13"><div class="content-0-0-14"><p><a href="/vc/">Home</a></p><div class="collapse-0-0-9 "><script id="FKfnIlWnfr">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("FKfnIlWnfr", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Workshops</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/workshops/imaging">Imaging &amp; Video</a>
<a href="/vc/docs/workshops/rendering">Rendering</a>
<a href="/vc/docs/workshops/algovis">Algovis</a>
<a href="/vc/docs/workshops/cg">Computer Graphics</a>
<a href="/vc/docs/workshops/hci">HCI</a></p></div></div><div class="collapse-0-0-9 "><script id="vabXSnoLUQ">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("vabXSnoLUQ", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">P5 Code Snippets</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/snippets/component">P5 Component</a>
<a href="/vc/docs/snippets/basic">Basics</a>
<a href="/vc/docs/snippets/video-dom">Video on dom</a>
<a href="/vc/docs/snippets/video-canvas">Video on canvas</a>
<a href="/vc/docs/snippets/3d">3D</a>
<a href="/vc/docs/snippets/lib">Libs</a>
<a href="/vc/docs/snippets/sound">Sound</a></p></div></div><div class="collapse-0-0-9 "><script id="XbfnajPcAk">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("XbfnajPcAk", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Members</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/members/mnguzmanc">Marcela Guzmán Caicedo</a>
<a href="/vc/docs/members/Alex">Alex Jose Alberto Barreto Cajica</a>
<a href="/vc/docs/members/snriverar">Sergio Nicolás Rivera</a></p></div></div></div><div class="search-0-0-15"><script id="ZPDlIxllKD">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("ZPDlIxllKD", "MChpnTvN8BpuKyiMGzmSYw==", {"repo":"vc","user":"alex22barreto","root":"docs/md","pick":"\\.md$","drop":"(^_)|(\\/_)"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><div class="footer-0-0-12"><div class="left"><script id="CcANfDiwxJ">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("CcANfDiwxJ", "X5W7He+ge/Kg3B6xB+T5gg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div><div class="main"><div class="inside"><a href="https://github.com/alex22barreto/vc/" target="_blank">GitHub</a></div></div><div class="right"><script id="_ZRckWNrXi">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("_ZRckWNrXi", "3ehN2Qj7wHC4donAKEDe0Q==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><script id="hxtNUkrvRF">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("hxtNUkrvRF", "bIAidu6MCPVPBcGGWLCR6Q==", {"namespace":"/vc"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></body></html>